"""
Comprehensive tests for enhanced AI features in LMS.
"""
import pytest
import asyncio
from fastapi.testclient import TestClient
from unittest.mock import patch, MagicMock
from enhanced_ai_generator import EnhancedAICourseGenerator


class TestEnhancedAICourseGenerator:
    """Test the enhanced AI course generator."""

    @pytest.fixture
    def ai_generator(self):
        """Create AI generator instance."""
        return EnhancedAICourseGenerator()

    @pytest.fixture
    def mock_ai_response(self):
        """Mock AI response for testing."""
        return {
            "title": "Test AI Generated Course",
            "description": "A comprehensive course generated by AI",
            "learning_objectives": ["Learn basic concepts", "Apply knowledge"],
            "prerequisites": ["Basic knowledge"],
            "lessons": [
                {
                    "id": "lesson_1",
                    "title": "Introduction",
                    "overview": "Introduction to the topic",
                    "duration_minutes": 60,
                    "key_concepts": ["concept1", "concept2"],
                    "learning_outcomes": ["outcome1", "outcome2"]
                }
            ]
        }

    def test_ai_generator_initialization(self, ai_generator):
        """Test AI generator initialization."""
        assert ai_generator is not None
        assert hasattr(ai_generator, '_initialize_ai')

    @patch('enhanced_ai_generator.genai.GenerativeModel')
    def test_generate_course_structure(self, mock_model, ai_generator, mock_ai_response):
        """Test course structure generation."""
        # Mock the AI response
        mock_response = MagicMock()
        mock_response.text = '{"title": "Test Course", "description": "Test description", "learning_objectives": ["Learn basics"], "prerequisites": [], "lessons": []}'
        mock_model.return_value.generate_content.return_value = mock_response

        # Test the method
        result = asyncio.run(ai_generator._generate_course_structure(
            "Test Topic", "Students", "intermediate", 5
        ))

        assert result is not None
        assert "title" in result
        assert "lessons" in result

    @patch('enhanced_ai_generator.genai.GenerativeModel')
    def test_generate_detailed_lesson(self, mock_model, ai_generator):
        """Test detailed lesson generation."""
        # Mock the AI response
        mock_response = MagicMock()
        mock_response.text = "This is a comprehensive lesson content with examples and practical exercises."
        mock_model.return_value.generate_content.return_value = mock_response

        lesson_outline = {
            "id": "lesson_1",
            "title": "Test Lesson",
            "overview": "Test overview",
            "duration_minutes": 60,
            "key_concepts": ["concept1"],
            "learning_outcomes": ["outcome1"]
        }

        result = asyncio.run(ai_generator._generate_detailed_lesson(
            lesson_outline, "Test Topic", "Students", "intermediate", 1,
            True, True, True
        ))

        assert result is not None
        assert result["title"] == "Test Lesson"
        assert "content" in result
        assert "practical_exercises" in result
        assert "assessment_questions" in result

    def test_safe_json_extract(self, ai_generator):
        """Test JSON extraction from AI responses."""
        # Test valid JSON
        json_str = '{"title": "Test", "content": "Test content"}'
        result = ai_generator._safe_json_extract(json_str)
        assert result["title"] == "Test"

        # Test invalid JSON
        invalid_json = "This is not JSON"
        with pytest.raises(ValueError):
            ai_generator._safe_json_extract(invalid_json)


class TestEnhancedAIFeaturesAPI:
    """Test enhanced AI features API endpoints."""

    @pytest.mark.asyncio
    async def test_enhanced_course_generation_request(self, test_client, auth_token):
        """Test enhanced course generation with more options."""
        request_data = {
            "topic": "Machine Learning",
            "audience": "Data Scientists",
            "difficulty": "advanced",
            "lessons_count": 25,
            "include_practical": True,
            "include_examples": True,
            "include_assessments": True,
            "custom_instructions": "Focus on practical applications"
        }

        response = test_client.post(
            "/api/courses/ai/generate_course",
            json=request_data,
            headers={"Authorization": f"Bearer {await auth_token}"}
        )

        # Should work even if AI fails (fallback to simple generation)
        assert response.status_code in [200, 500]  # 200 if successful, 500 if AI fails

        if response.status_code == 200:
            data = response.json()
            assert "title" in data
            assert "lessons" in data
            assert len(data["lessons"]) <= 25

    @pytest.mark.asyncio
    async def test_content_enhancement_endpoint(self, test_client, instructor_token):
        """Test content enhancement endpoint."""
        request_data = {
            "content": "Basic introduction to Python programming",
            "type": "comprehensive",
            "audience": "beginners",
            "difficulty": "beginner"
        }

        response = test_client.post(
            "/api/courses/ai/enhance_content",
            json=request_data,
            headers={"Authorization": f"Bearer {await instructor_token}"}
        )

        # Should work even if AI fails
        assert response.status_code in [200, 500]

        if response.status_code == 200:
            data = response.json()
            assert "enhanced_content" in data
            assert "enhancement_type" in data

    @pytest.mark.asyncio
    async def test_personalize_course_endpoint(self, test_client, auth_token, test_course):
        """Test course personalization endpoint."""
        course = await test_course
        request_data = {
            "course_id": course["_id"],
            "learning_style": "visual",
            "prior_knowledge": "intermediate",
            "goals": ["Get job ready", "Build portfolio"],
            "pace_preference": "moderate"
        }

        response = test_client.post(
            "/api/courses/ai/personalize_course",
            json=request_data,
            headers={"Authorization": f"Bearer {await auth_token}"}
        )

        assert response.status_code in [200, 500]

        if response.status_code == 200:
            data = response.json()
            assert "personalization" in data
            assert "personalized_lessons" in data

    @pytest.mark.asyncio
    async def test_interactive_content_generation(self, test_client, instructor_token):
        """Test interactive content generation."""
        request_data = {
            "topic": "Database Design",
            "content_type": "scenario",
            "difficulty": "intermediate",
            "duration": 20
        }

        response = test_client.post(
            "/api/courses/ai/generate_interactive_content",
            json=request_data,
            headers={"Authorization": f"Bearer {await instructor_token}"}
        )

        assert response.status_code in [200, 500]

        if response.status_code == 200:
            data = response.json()
            assert "interactive_content" in data
            assert data["content_type"] == "scenario"

    @pytest.mark.asyncio
    async def test_learning_patterns_analysis(self, test_client, auth_token):
        """Test learning patterns analysis."""
        request_data = {
            "course_id": "any_course_id",
            "time_period_days": 30
        }

        response = test_client.post(
            "/api/courses/ai/analyze_learning_patterns",
            json=request_data,
            headers={"Authorization": f"Bearer {await auth_token}"}
        )

        assert response.status_code in [200, 500]

        if response.status_code == 200:
            data = response.json()
            assert "analysis" in data
            assert "metrics" in data

    @pytest.mark.asyncio
    async def test_adaptive_content_generation(self, test_client, auth_token, test_course):
        """Test adaptive content generation."""
        course = await test_course
        request_data = {
            "course_id": course["_id"],
            "performance_data": {"average_score": 75},
            "struggling_topics": ["Complex Queries"],
            "mastered_topics": ["Basic SQL"]
        }

        response = test_client.post(
            "/api/courses/ai/generate_adaptive_content",
            json=request_data,
            headers={"Authorization": f"Bearer {await auth_token}"}
        )

        assert response.status_code in [200, 500]

        if response.status_code == 200:
            data = response.json()
            assert "adaptive_content" in data
            assert "adaptive_plan" in data

    @pytest.mark.asyncio
    async def test_unlimited_lesson_generation(self, test_client, instructor_token):
        """Test generation of courses with many lessons."""
        # Test with 50 lessons
        request_data = {
            "topic": "Full Stack Development",
            "audience": "Developers",
            "difficulty": "intermediate",
            "lessons_count": 50,
            "include_practical": True,
            "include_examples": True,
            "include_assessments": True
        }

        response = test_client.post(
            "/api/courses/ai/generate_course",
            json=request_data,
            headers={"Authorization": f"Bearer {await instructor_token}"}
        )

        assert response.status_code in [200, 500]

        if response.status_code == 200:
            data = response.json()
            # Should generate up to the requested number or fall back gracefully
            assert len(data["lessons"]) <= 50

    @pytest.mark.asyncio
    async def test_max_lesson_limit(self, test_client, instructor_token):
        """Test maximum lesson limit (100)."""
        request_data = {
            "topic": "Advanced Topics",
            "audience": "Experts",
            "difficulty": "advanced",
            "lessons_count": 150,  # Over limit
            "include_practical": True
        }

        response = test_client.post(
            "/api/courses/ai/generate_course",
            json=request_data,
            headers={"Authorization": f"Bearer {await instructor_token}"}
        )

        # Should either reject or limit to maximum
        assert response.status_code in [200, 400, 500]

        if response.status_code == 200:
            data = response.json()
            assert len(data["lessons"]) <= 100  # Should not exceed max limit


class TestAIFallbackMechanisms:
    """Test AI fallback mechanisms when services are unavailable."""

    @pytest.mark.asyncio
    async def test_fallback_to_simple_generation(self, test_client, instructor_token):
        """Test fallback to simple generation when enhanced AI fails."""
        # This test ensures the system gracefully degrades
        request_data = {
            "topic": "Test Topic",
            "audience": "Students",
            "difficulty": "beginner",
            "lessons_count": 5
        }

        response = test_client.post(
            "/api/courses/ai/generate_course",
            json=request_data,
            headers={"Authorization": f"Bearer {await instructor_token}"}
        )

        # Should always return a response (either enhanced or fallback)
        assert response.status_code == 200
        data = response.json()
        assert "title" in data
        assert "lessons" in data
        assert len(data["lessons"]) > 0

    @pytest.mark.asyncio
    async def test_ai_service_unavailable_handling(self, test_client, instructor_token):
        """Test handling when AI service is completely unavailable."""
        # This would require mocking the AI service to be unavailable
        # For now, we test that the endpoint handles errors gracefully
        request_data = {
            "topic": "Error Handling Test",
            "audience": "Developers",
            "difficulty": "intermediate",
            "lessons_count": 3
        }

        response = test_client.post(
            "/api/courses/ai/generate_course",
            json=request_data,
            headers={"Authorization": f"Bearer {await instructor_token}"}
        )

        # Should handle AI unavailability gracefully
        assert response.status_code in [200, 500]

        if response.status_code == 200:
            data = response.json()
            assert isinstance(data, dict)
            assert "title" in data


class TestEnhancedContentQuality:
    """Test the quality and comprehensiveness of enhanced content."""

    @pytest.mark.asyncio
    async def test_comprehensive_lesson_content(self, test_client, instructor_token):
        """Test that enhanced lessons have comprehensive content."""
        request_data = {
            "topic": "Web Development",
            "audience": "Beginners",
            "difficulty": "beginner",
            "lessons_count": 10,
            "include_practical": True,
            "include_examples": True,
            "include_assessments": True
        }

        response = test_client.post(
            "/api/courses/ai/generate_course",
            json=request_data,
            headers={"Authorization": f"Bearer {await instructor_token}"}
        )

        if response.status_code == 200:
            data = response.json()
            lessons = data["lessons"]

            # Check that lessons have comprehensive structure
            for lesson in lessons:
                assert "title" in lesson
                assert "content" in lesson
                # Content should be substantial (more than basic generation)
                assert len(lesson["content"]) > 100

    @pytest.mark.asyncio
    async def test_practical_content_inclusion(self, test_client, instructor_token):
        """Test that practical exercises are included when requested."""
        request_data = {
            "topic": "Python Programming",
            "audience": "Students",
            "difficulty": "intermediate",
            "lessons_count": 8,
            "include_practical": True,
            "include_examples": True
        }

        response = test_client.post(
            "/api/courses/ai/generate_course",
            json=request_data,
            headers={"Authorization": f"Bearer {await instructor_token}"}
        )

        if response.status_code == 200:
            data = response.json()
            # Check that the course was stored with enhanced content
            assert "generated_content" in data or len(data["lessons"]) > 0

    @pytest.mark.asyncio
    async def test_custom_instructions_handling(self, test_client, instructor_token):
        """Test that custom instructions are processed."""
        request_data = {
            "topic": "Data Science",
            "audience": "Professionals",
            "difficulty": "advanced",
            "lessons_count": 12,
            "include_practical": True,
            "custom_instructions": "Focus heavily on real-world industry applications and case studies"
        }

        response = test_client.post(
            "/api/courses/ai/generate_course",
            json=request_data,
            headers={"Authorization": f"Bearer {await instructor_token}"}
        )

        # Should handle custom instructions gracefully
        assert response.status_code in [200, 500]